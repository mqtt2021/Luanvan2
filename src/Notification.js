import React,{useState, useEffect, useContext} from 'react'
import { RiGpsFill } from "react-icons/ri";
import { TiBatteryCharge } from "react-icons/ti";
import './Notification.scss'
import { GiPositionMarker } from "react-icons/gi";
import { FaBell } from "react-icons/fa";
import { IoMdSettings } from "react-icons/io";
import { IoMdAddCircle } from "react-icons/io";
import {Link, useNavigate} from "react-router-dom";   
import ModalAddDevice from './settingDevice/AddDevice';
import { MdDirectionsRun } from "react-icons/md";
import { FaCircle } from "react-icons/fa";
import { IoIosWarning } from "react-icons/io";
import { FaConnectdevelop } from "react-icons/fa";
import { FiWifi } from "react-icons/fi";
import { FiWifiOff } from "react-icons/fi";   
import { MdBrowserUpdated } from "react-icons/md";     
import { PiBatteryWarningFill } from "react-icons/pi";
import axios from 'axios';
import { url } from './services/UserService';
import { UserContext } from './usercontext';                 
import { GrUpdate } from "react-icons/gr";
import * as signalR from "@microsoft/signalr";
import { MdError } from "react-icons/md";
function Notification() { 


const { unreadCount, setUnreadCount  } =  useContext(UserContext);    

  const [connection, setConnection] = useState(null);
  const [isLoading, setIsLoading] = useState(true); // Th√™m state ƒë·ªÉ qu·∫£n l√Ω tr·∫°ng th√°i loading
  const [listNotifications, setListNotifications] = useState([]);
  const [phone, setPhone] = useState('');
  const [showModalAddDevice, setshowModalAddDevice] = useState(false);

  const [listAllDeices, setListAllDeices] = useState([]);   

  const handleshowModalAddDevice = ()=> {   
        setshowModalAddDevice(true)       
  }
  const handleCloseModalAddDeice = ()=>{
        setshowModalAddDevice(false)     
  } 

  const getNotification = async () => {
    setIsLoading(true); // B·∫Øt ƒë·∫ßu loading
    let success = false;  
    while (!success) {   
      try {
        const response = await axios.get(`${url}/Notification/GetNotificationByPhoneNumber?phoneNumber=${phone}`);   
        const NotificationsData = response.data;
  
        // Ki·ªÉm tra n·∫øu d·ªØ li·ªáu nh·∫≠n ƒë∆∞·ª£c h·ª£p l·ªá
        if (NotificationsData) {    
          // const ListStolen = LoggerData.filter((item) => item.stolenLines.length > 0);
          const sortedData = NotificationsData.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

          
          const uniqueNotifications = sortedData.reduce((acc, item) => {
            const exists = acc.find((t) => t.title === item.title && t.timestamp === item.timestamp);
            if (!exists) {
              acc.push(item); // Ch·ªâ th√™m v√†o danh s√°ch n·∫øu ch∆∞a c√≥
            }
          return acc;
          }, []);

          const unreadCount = uniqueNotifications.filter((item) => item.isAcknowledge === false).length;
          setUnreadCount(unreadCount)

          setListNotifications(uniqueNotifications);    
          
          success = true; // D·ª´ng v√≤ng l·∫∑p khi d·ªØ li·ªáu h·ª£p l·ªá v√† ƒë∆∞·ª£c x·ª≠ l√Ω
        } else {
          alert('ReLoad');
        }
      } catch (error) {
        //console.error('getNotification error, retrying...', error);
        await new Promise(resolve => setTimeout(resolve, 1000)); // ƒê·ª£i 2 gi√¢y tr∆∞·ªõc khi th·ª≠ l·∫°i
      }
    }
    
  };

  const UpdateAcknowledge = async (title, description, timestamp, isAcknowledge) => {   

    if(!isAcknowledge){
      let success = false;
      while (!success) {
        try {
          const response = await axios.patch(`${url}/Notification/UpdateNotification`, {
            "customerPhoneNumber": phone,
            "title": title,                     
            "timestamp": timestamp 
          });  
          const LoggerData = response.data;
    
          // Ki·ªÉm tra n·∫øu d·ªØ li·ªáu nh·∫≠n ƒë∆∞·ª£c h·ª£p l·ªá            
          if (LoggerData && LoggerData.length > 0) {
            success = true; 
            // G·ªçi l·∫°i h√†m getNotification sau khi c·∫≠p nh·∫≠t th√†nh c√¥ng
            await getNotification();
          }
        } catch (error) {
          console.error('getAllDevices error, retrying...', error);  
          await new Promise(resolve => setTimeout(resolve, 1000)); // ƒê·ª£i 1 gi√¢y tr∆∞·ªõc khi th·ª≠ l·∫°i
        }
      }
    }
    
  };
  


  const getAllDevices = async () => {   
    setIsLoading(true); // B·∫Øt ƒë·∫ßu loading
    let success = false;
    while (!success) {
      try {
        const response = await axios.get(`${url}/GPSDevice/GetAllGPSDevices`);  
        const LoggerData = response.data;
  
        // Ki·ªÉm tra n·∫øu d·ªØ li·ªáu nh·∫≠n ƒë∆∞·ª£c h·ª£p l·ªá
        if (LoggerData && LoggerData.length > 0) {

          const phoneNumer = sessionStorage.getItem('phoneNumer');
          const listDevice = LoggerData.filter((item) => item.customerPhoneNumber === phoneNumer);
          setListAllDeices(listDevice);
          success = true; 
        } else {

        }
      } catch (error) {
        console.error('getAllDevices error, retrying...', error);  
        await new Promise(resolve => setTimeout(resolve, 1000)); // ƒê·ª£i 2 gi√¢y tr∆∞·ªõc khi th·ª≠ l·∫°i
      }
    }
    setIsLoading(false); // B·∫Øt ƒë·∫ßu loading
  };


  const postDataToAPI = async (url, data) => {
    try {
      const response = await axios.post(`${url}/Notification/GetNotificationByPhoneNumber?phoneNumber=${phone}`, {
        headers: {
          'Content-Type': 'application/json',
        }
      });
      //console.log('Response:', response.data);
      return response.data; // Tr·∫£ v·ªÅ d·ªØ li·ªáu t·ª´ server n·∫øu c·∫ßn d√πng ti·∫øp
    } catch (error) {
      console.error('POST request failed:', error);
      return null; // Tr·∫£ v·ªÅ null n·∫øu l·ªói
    }
  };

  useEffect(() => {  
    const phoneNumer = sessionStorage.getItem('phoneNumer');    
    setPhone(phoneNumer)    
  }, [])
  
  useEffect(() => { 
    if(phone !== ''){
      getNotification();
      getAllDevices()
    }                     
  }, [phone])


  useEffect(() => { 
    if(listNotifications.length > 0){
      setIsLoading(false); // K·∫øt th√∫c loading sau khi l·∫•y d·ªØ li·ªáu xong
    }                     
  }, [listNotifications])

  // useEffect(() => {    
  //   if(connection !== null){     
  //     getAllDevices(connection)   
  //   }                     
  // }, [connection])

  function convertDateTimeBefore(inputString) {
    const [date, time] = inputString.split('T');    
    const [year, month, day] = date.split('-');
    return `${day}-${month}-${year} ${time}`;    
  }

  const iconMap = {
    "Pin y·∫øu": <PiBatteryWarningFill className='iconDevice' />,
    "C·∫£nh b√°o chuy·ªÉn ƒë·ªông": <MdDirectionsRun className='iconDevice' />,
    "V√πng an to√†n": <IoIosWarning className='iconDevice' />, // Th√™m icon kh√°c
    "C·∫≠p nh·∫≠t v·ªã tr√≠": <GrUpdate className='iconDevice' />, // Th√™m icon kh√°c
  }


  useEffect( () => {
    let connection = new signalR.HubConnectionBuilder()   
        .withUrl("https://mygps.runasp.net/NotificationHub")   
        .withAutomaticReconnect()    
        .build();     
    // B·∫Øt ƒë·∫ßu k·∫øt n·ªëi   
    connection.start()   
        .then(() => {  
          console.log("‚úÖ K·∫øt n·ªëi SignalR th√†nh c√¥ng!");
                     // L·∫Øng nghe c√°c s·ª± ki·ªán cho t·ª´ng thi·∫øt b·ªã
        listAllDeices.forEach(device => {
          connection.on(`SendNotification${device.id}`, data => {
            const obj = JSON.parse(data);
            console.log(`üì° D·ªØ li·ªáu t·ª´ thi·∫øt b·ªã ${device.id}:`, obj);
             // ƒê·ª£i 2 gi√¢y tr∆∞·ªõc khi g·ªçi getNotification
            setTimeout(() => {
              getNotification();
            }, 4000);
          });
        });
         
          
        })
        .catch(err => {
            console.error('K·∫øt n·ªëi th·∫•t b·∫°i: ', err);
        });
    // L·∫Øng nghe s·ª± ki·ªán k·∫øt n·ªëi l·∫°i
    connection.onreconnected(connectionId => {
        console.log(`K·∫øt n·ªëi l·∫°i th√†nh c√¥ng. Connection ID: ${connectionId}`);
    });
    // L·∫Øng nghe s·ª± ki·ªán ƒëang k·∫øt n·ªëi l·∫°i
    connection.onreconnecting(error => {
        console.warn('K·∫øt n·ªëi ƒëang ƒë∆∞·ª£c th·ª≠ l·∫°i...', error);
    });
    // Cleanup khi component unmount ho·∫∑c khi listAllDeices thay ƒë·ªïi
    return () => {
      connection.stop();
      console.log("üî¥ K·∫øt n·ªëi SignalR ƒë√£ ƒë√≥ng!");
    };
  }, [listAllDeices] )



  // const uniqueNotifications = listNotifications.reduce((acc, item) => {
  //     const exists = acc.find((t) => t.title === item.title && t.timestamp === item.timestamp);
  //     if (!exists) {
  //       acc.push(item); // Ch·ªâ th√™m v√†o danh s√°ch n·∫øu ch∆∞a c√≥
  //     }
  // return acc;
  // }, []);


  // useEffect(() => {
  //   // Kh·ªüi t·∫°o k·∫øt n·ªëi SignalR
  //   let conn = new signalR.HubConnectionBuilder()  
  //       .withUrl("https://mygps.runasp.net/NotificationHub")     
  //       .withAutomaticReconnect()
  //       .build();
  //   conn.start()
  //       .then(() => {
  //           //console.log(" K·∫øt n·ªëi SignalR th√†nh c√¥ng!");
  //           setConnection(conn); // L∆∞u connection v√†o state
  //           getAllDevices(conn); // G·ªçi API sau khi k·∫øt n·ªëi th√†nh c√¥ng
  //       })
  //       .catch(err => console.error(" K·∫øt n·ªëi th·∫•t b·∫°i: ", err));
  //   return () => {
  //       conn.stop(); // D·ªçn d·∫πp k·∫øt n·ªëi khi component b·ªã unmount
  //   };
  // }, []);


  return (
    <div className='fatherNotification'>
      <div className='wrapperNotification'>
      
            <div className='TitleNotification'>
                    <div className='TitleNotificationItem'>
                          Th√¥ng b√°o
                    </div> 
            </div>

            {
              isLoading ? (
                    <div className="loadingContainer">
                            <div className="spinner"></div> {/* Hi·ªÉn th·ªã hi·ªáu ·ª©ng loading */}
                            <p>ƒêang t·∫£i th√¥ng b√°o...</p>                              
                    </div>
              ) :
              
              (listNotifications.map((item , index) => (  
              <div
                  className='wrapperContainerNotification'
                  onClick={() => UpdateAcknowledge(item.title, item.description, item.timestamp, item.isAcknowledge)}
 
              >        
                <div className='containerDevice'>
                  <div className='itemDevice itemDeviceFirst'>
                      <div className='divIconDevice'>    
                              {iconMap[item.title] || <MdError className='iconDevice' />}                      
                      </div>    
                      <div className='divIconNameAndPin'>
                          <div className='name'>
                            {item.title}  
                          </div>
                          <div className='divIconPin'>  
                            <div>{item.description}</div>   
                          </div>
                      </div>
                  </div>
                  <div className='itemDevice itemNotificationecond'>
                          <div className = 'itemNotificationecondItem'>  
                              {convertDateTimeBefore(item.timestamp)}
                          </div>
                          {item.isAcknowledge ?
                          
                            <div className = 'itemNotificationecondItem' style={{ fontStyle: "italic" }}>                            
                                    ƒê√£ xem
                            </div>  

                            :

                            <div className = 'itemNotificationecondItem'>                            
                              <FaCircle className='iconAcknownledge' />
                            </div>
                          
                           }
                                       
                  </div>

                </div>
              </div>                              
              ))  )}
      </div>   
              
    </div>
  )
}

export default Notification
